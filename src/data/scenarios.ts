import type { Scenario, ScenarioComplexity, ScenarioSection } from "@/types";
import type { SnippetId } from "@/data/code-snippets";

const unorderedScenarios: Scenario[] = [
  {
    id: "simple-payment",
    title: "Simple Invoice Payment",
    description:
      "Alice creates a BOLT-11 invoice, Bob pays it. The fundamental Lightning payment flow.",
    education:
      "Lightning invoices can be shared as text or displayed as a QR code, or opened as a link in a lightning wallet. Invoices can only be used once.",
    complexity: "simplest",
    requiredWallets: ["alice", "bob"],
    icon: "ğŸ’¸",
    snippetIds: ["make-invoice", "pay-invoice"] satisfies SnippetId[],
    prompts: [
      {
        title: "Pay-to-Continue Minesweeper",
        description:
          "Build a minesweeper game where hitting a mine lets you pay sats to resume instead of restarting.",
        prompt: `Build a minesweeper game where the player can pay a Lightning invoice to continue after hitting a mine.

Requirements:
- A playable minesweeper grid (e.g. 10x10 with 15 mines)
- Standard minesweeper rules: reveal tiles, flag mines, number hints
- When the player hits a mine, show a "Game Over" overlay with two options:
  - "Restart" (free, resets the board)
  - "Continue" (costs sats, removes the mine and lets the player keep playing)
- "Continue" generates a Lightning invoice, displays it as a QR code
- After payment is confirmed, dismiss the overlay and let the player resume
- Each continue costs more than the last (e.g. 10, 25, 50, 100 sats)
- Show a scoreboard with total sats spent and tiles cleared
- Use React and TypeScript
- Write tests using vitest and playwright. Take screenshots and review the screenshots.

The flow: Play â†’ hit mine â†’ pay invoice to continue or restart for free.`,
      },
    ],
  },
  {
    id: "lookup-invoice",
    title: "Lookup Invoice Status",
    description:
      "Alice creates an invoice, Bob pays it. Alice can look up the status of the invoice at any time.",
    education:
      "With NWC you can lookup that status of invoices generated by your wallet at any time. This is useful for verifying whether a payment has been received, especially in scenarios where you need to poll for payment confirmation.",
    complexity: "simple",
    requiredWallets: ["alice", "bob"],
    icon: "ğŸ”",
    snippetIds: [
      "make-invoice",
      "lookup-invoice",
      "pay-invoice",
    ] satisfies SnippetId[],
    prompts: [
      {
        title: "Point of Sale Terminal",
        description:
          "Build a simple point-of-sale terminal that creates invoices and confirms payment in real time.",
        prompt: `Build a point-of-sale (PoS) terminal that accepts Lightning payments.

Requirements:
- A keypad or input to enter the charge amount in sats
- An optional description field for the item or order
- A "Charge" button that creates an invoice and displays it as a large QR code
- Poll the invoice status and show a clear "Pending..." indicator while waiting
- When paid, show a success screen with a checkmark and the amount received
- A "New Sale" button to reset and start the next transaction
- Keep a list of completed sales for the current session
- Use React and TypeScript
- Write tests using vitest and playwright. Take screenshots and review the screenshots.

The flow: Enter amount â†’ charge â†’ show QR â†’ poll status â†’ payment confirmed â†’ ready for next sale.`,
      },
    ],
  },
  {
    id: "lnurl-verify",
    title: "LNURL-Verify",
    description:
      "Alice requests an invoice from Bob. Alice can look up the status of the invoice at any time.",
    education:
      "LNURL-Verify allows you to check the status of an invoice at any time without having access to the recipient's wallet. This is useful for verifying whether a payment has been sent, especially in scenarios where you need to poll for payment confirmation.",
    complexity: "medium",
    requiredWallets: ["alice", "bob"],
    icon: "ğŸ”",
    snippetIds: [
      "request-invoice-from-address",
      "pay-invoice",
      "lnurl-verify",
    ] satisfies SnippetId[],
    prompts: [
      {
        title: "Tip Jar / Donation Page",
        description:
          "Build a public donation page that verifies tips were received using LNURL-verify.",
        prompt: `Build a tip jar page where users send tips to a Lightning Address and the app verifies payment using LNURL-verify.

Requirements:
- Display a creator profile (name, avatar placeholder, bio)
- Input field for tip amount in sats with preset buttons (100, 500, 1000, 5000 sats)
- Optional message field from the tipper
- Request an invoice from the creator's Lightning Address
- Display the invoice as a QR code for the tipper to pay
- Use the LNURL-verify URL returned with the invoice to poll for payment confirmation (no wallet access needed)
- Show a thank you screen when LNURL-verify confirms the payment
- Display a running list of verified tips
- Use React and TypeScript
- Write tests using vitest and playwright. Take screenshots and review the screenshots.
- No backend is needed

The flow: Choose amount â†’ request invoice from Lightning Address â†’ show QR â†’ verify payment via LNURL-verify â†’ show confirmation.`,
      },
    ],
  },
  {
    id: "lightning-address",
    title: "Lightning Address",
    description:
      "Pay to a Lightning Address (like email). The system handles invoice creation automatically.",
    education:
      "You can share a lightning address publicly to receive payments from anyone. Lightning addresses can be shared as text or as a QR code, or opened as a link in a lightning wallet.",
    complexity: "simple",
    requiredWallets: ["alice", "bob"],
    icon: "ğŸ”Œ",
    snippetIds: [
      "fetch-lightning-address",
      "request-invoice-from-address",
      "pay-lightning-address",
      "pay-invoice",
    ] satisfies SnippetId[],
    prompts: [
      {
        title: "Rewards App",
        description:
          "Build an app where users register their Lightning Address and earn sats for completing actions.",
        prompt: `Build a rewards app that pays users to their Lightning Address when they complete actions.

Requirements:
- A registration form where users enter their name and Lightning Address
- A list of available tasks/actions (e.g. "Complete survey", "Refer a friend", "Watch a video")
- Each action has a reward amount in sats
- When a user completes an action, pay out the reward to their Lightning Address
- Show a confirmation with the payment details after each payout
- Display a leaderboard of users and their total earnings
- Store user profiles and completed actions in local state
- Use React and TypeScript
- Write tests using vitest and playwright. Take screenshots and review the screenshots.

The flow: Register Lightning Address â†’ complete an action â†’ receive sats payout â†’ see earnings on leaderboard.`,
      },
    ],
  },
  {
    id: "notifications",
    title: "Payment Notifications",
    description:
      "Subscribe to real-time payment notifications and react to incoming and outgoing payments.",
    education:
      "NWC supports subscribing to payment notifications, allowing your app to react instantly when payments are received.",
    complexity: "medium",
    requiredWallets: ["alice", "bob"],
    icon: "ğŸ””",
    snippetIds: [
      "subscribe-notifications",
      "request-invoice-from-address",
      "pay-lightning-address",
      "pay-invoice",
    ] satisfies SnippetId[],
    prompts: [
      {
        title: "Streamer QR Donation Page",
        description:
          "Build a streamer overlay page that shows a QR code and plays alerts when payments arrive.",
        prompt: `Build a streamer donation page with real-time payment alerts.

Requirements:
- Display a large QR code for the streamer's Lightning Address or a static invoice
- Subscribe to payment notifications to react when payments arrive
- When a payment is received, show an animated alert overlay with the amount and sender message
- Play a sound effect on each new payment (use a simple beep or chime)
- Keep a live feed of recent donations scrolling on screen
- Show running total of donations received in the session
- Use React and TypeScript
- Write tests using vitest and playwright. Take screenshots and review the screenshots.

The flow: Show QR â†’ listener receives notification â†’ animate alert â†’ update donation feed.`,
      },
      {
        title: "Zap Lamp",
        description:
          "Build a virtual zap lamp that lights up and animates every time a Lightning payment is received.",
        prompt: `Build a virtual zap lamp that reacts to incoming Lightning payments with light animations.

Requirements:
- Display a large visual lamp or lightbulb in the center of the screen (use CSS/SVG, no images needed)
- The lamp starts in an "off" or dim state
- Subscribe to payment notifications on the connected wallet
- When a payment is received:
  - The lamp lights up with a bright glow animation
  - The color and intensity scale with the payment amount (e.g. small payments = warm yellow, large payments = bright white or electric blue)
  - Show the amount received as a floating label near the lamp
  - The glow fades out after a few seconds
- Display a payment counter and total sats received
- Show a live feed of recent payments below the lamp
- Include a "lamp status" indicator: idle, glowing, cooldown
- Use React and TypeScript
- Write tests using vitest and playwright. Take screenshots and review the screenshots.

The flow: Connect wallet â†’ subscribe to notifications â†’ receive payment â†’ lamp glows with amount-based intensity â†’ fade back to idle.`,
      },
      {
        title: "Lightning Goats",
        description:
          "Build a fun app where goats get fed every time a Lightning payment is received â€” inspired by the real Lightning Goats project.",
        prompt: `Build a Lightning Goats app where incoming payments trigger a virtual goat feeding.

Requirements:
- Display a pasture scene with goat characters (use emoji ğŸ or simple CSS illustrations)
- Show a feeding trough that starts empty
- Subscribe to payment notifications on the connected wallet
- When a payment is received:
  - Animate food appearing in the trough (amount of food scales with sats received)
  - Goats walk over to the trough and start eating with a fun animation
  - Show a "+X sats" popup and a "Nom nom!" message
  - Play a goat bleat sound effect (optional, use a simple audio tone as fallback)
- Track feeding stats:
  - Total sats received
  - Number of feedings
  - "Goat happiness" meter that increases with more feedings
- Show a live log of recent feedings with timestamps and amounts
- Include a shareable Lightning Address or QR code so anyone can feed the goats
- Use React and TypeScript
- Write tests using vitest and playwright. Take screenshots and review the screenshots.

The flow: Display goat pasture â†’ subscribe to notifications â†’ receive payment â†’ animate goat feeding â†’ update stats â†’ wait for next payment.`,
      },
    ],
  },
  {
    id: "subscription-payments",
    title: "Subscription Payments",
    description:
      "Alice pays Bob on a regular interval using a budgeted wallet connection.",
    education:
      "Users can give budgeted wallet connections to a service so that the service can charge them on a regular interval. This enables subscription-based business models on Lightning.",
    howItWorks: [
      {
        title: "Connect",
        description:
          "Alice provides Bob with her NWC connection, which has spending permissions.",
      },
      {
        title: "Configure",
        description:
          "Alice sets the payment amount and interval for the subscription.",
      },
      {
        title: "Charge",
        description:
          "Bob uses Alice's connection to pay invoices to himself on a regular schedule.",
      },
    ],
    complexity: "medium",
    requiredWallets: ["alice", "bob"],
    icon: "ğŸ”„",
    snippetIds: [
      "subscribe-notifications",
      "request-invoice-from-address",
      "pay-lightning-address",
      "pay-invoice",
    ] satisfies SnippetId[],
    prompts: [
      {
        title: "SaaS Subscription Manager",
        description:
          "Build a subscription service that charges users on a recurring schedule via their wallet connection.",
        prompt: `Build a SaaS subscription manager that charges users recurring Lightning payments.

Requirements:
- A subscription plan selector (e.g. Basic 1000 sats/month, Pro 5000 sats/month)
- User provides a wallet connection to authorize recurring charges
- Service creates invoices on its own wallet and pays them using the user's connection
- Display subscription status: active, payment due, payment failed
- Show payment history with dates and amounts
- A cancel subscription button that stops the recurring charges
- Use React and TypeScript
- Write tests using vitest and playwright. Take screenshots and review the screenshots.

The flow: User selects plan â†’ provides wallet connection â†’ service charges on schedule â†’ user sees payment history.`,
      },
      {
        title: "Recurring Donation Platform",
        description:
          "Build a platform where users set up recurring donations to any Lightning Address.",
        prompt: `Build a recurring donation platform that sends scheduled payments to a Lightning Address.

Requirements:
- Input field for the recipient's Lightning Address
- Input field for the donation amount in sats
- Frequency selector (e.g. every 10 seconds for demo, or daily/weekly/monthly)
- A "Start Donations" button that begins the recurring schedule
- Each interval, request an invoice from the Lightning Address and pay it
- Show a live log of each donation sent with timestamp, amount, and status
- Display a running total of sats donated
- A "Stop" button to cancel the recurring donations
- Use React and TypeScript
- Write tests using vitest and playwright. Take screenshots and review the screenshots.

The flow: Enter Lightning Address, amount, and frequency â†’ start â†’ auto-pay on schedule â†’ see live donation log.`,
      },
    ],
  },
  {
    id: "hold-invoice",
    title: "Hold Invoice",
    description:
      "Create an invoice that can be conditionally settled or cancelled.",
    education:
      "Hold invoices allow you to accept a payment but delay the final settlement. This is useful for escrow-like scenarios where you want to verify something before completing the payment. The invoice must be settled before the specified block time.",
    howItWorks: [
      {
        title: "Create",
        description:
          "Alice generates a preimage and its hash. The hash is included in the invoice.",
      },
      {
        title: "Hold",
        description:
          "Bob pays, but funds are locked. Only Alice has the preimage to claim them.",
      },
      {
        title: "Settle/Cancel",
        description:
          "Alice reveals preimage to receive funds, or cancels to refund Bob.",
      },
    ],
    complexity: "advanced",
    requiredWallets: ["alice", "bob"],
    icon: "ğŸ”’",
    snippetIds: [
      "hold-invoice",
      "subscribe-hold-notifications",
      "hold-invoice-settle",
      "hold-invoice-cancel",
      "pay-invoice",
    ] satisfies SnippetId[],
    prompts: [
      {
        title: "Coinflip Game",
        description:
          "Build a provably fair coinflip game where two players bet sats using hold invoices as escrow, and the winner gets paid.",
        prompt: `Build a provably fair coinflip game using hold invoices for escrow.

Requirements:
- Two players each provide a wallet connection
- Each player commits a bet amount (must match)
- The house creates a hold invoice for each player, and each player pays it (funds are locked, not yet settled)
- Flip a coin (use a random number or hash-based fairness scheme)
- The loser's hold invoice is settled (house collects the funds)
- The winner's hold invoice is cancelled (refunded) and the house pays the winnings to the winner's Lightning Address
- Display game state: waiting for bets, both paid, flipping, result, payout
- Show provably fair verification details
- Use React and TypeScript
- Write tests using vitest and playwright. Take screenshots and review the screenshots.

The flow: Both players bet â†’ hold invoices lock funds â†’ coin flips â†’ loser's invoice settled â†’ winner refunded + paid winnings â†’ result shown.`,
      },
      {
        title: "No Delivery, No Pay â€” Food Delivery",
        description:
          "Build a food delivery service where the customer's payment is held until delivery is confirmed, then settled or refunded.",
        prompt: `Build a food delivery app that uses hold invoices so customers only pay if their order is delivered.

Requirements:
- Customer places an order by selecting items from a menu (e.g. burger 500 sats, pizza 800 sats, drink 200 sats)
- The service creates a hold invoice for the order total
- Customer pays the hold invoice â€” funds are locked but not yet settled
- Display the order lifecycle with clear status steps:
  - "Order placed" â†’ "Payment held" â†’ "Preparing" â†’ "Out for delivery" â†’ "Delivered" / "Cancelled"
- A delivery driver panel with buttons to advance the order through each stage
- If the driver marks the order as "Delivered":
  - Settle the hold invoice (merchant receives the funds)
  - Show a confirmation receipt to the customer
- If the order is cancelled at any stage before delivery:
  - Cancel the hold invoice (customer is refunded)
  - Show a refund notice to the customer
- Display a timer showing how long funds have been held
- Use React and TypeScript
- Write tests using vitest and playwright. Take screenshots and review the screenshots.

The flow: Customer orders â†’ pays hold invoice â†’ funds locked â†’ driver delivers â†’ settle invoice, or cancel â†’ refund customer.`,
      },
      {
        title: "Lightning Liquidity Service (LSP)",
        description:
          "Build an LSP that opens a channel for a client, using a hold invoice so the client only pays if the channel is successfully opened.",
        prompt: `Build a simulated Lightning Service Provider (LSP) that uses hold invoices so clients only pay if a channel is opened.

Requirements:
- Client requests a channel by specifying a desired capacity in sats (e.g. 50,000 or 100,000 sats)
- The LSP calculates a fee (e.g. 1% of capacity) and creates a hold invoice for the fee amount
- Client pays the hold invoice â€” funds are locked but not yet settled
- Display the channel opening lifecycle:
  - "Fee invoice paid" â†’ "Opening channel..." â†’ "Channel confirmed" / "Channel failed"
- An LSP operator panel with controls to simulate:
  - "Channel Opened" â€” settles the hold invoice, LSP keeps the fee
  - "Channel Failed" â€” cancels the hold invoice, client is refunded
- Show channel details when opened: capacity, channel ID (simulated), node public key
- If the hold invoice times out before a decision, it is automatically cancelled (refund)
- Display both client and LSP perspectives side by side
- Use React and TypeScript
- Write tests using vitest and playwright. Take screenshots and review the screenshots.

The flow: Client requests channel â†’ pays hold invoice fee â†’ LSP attempts to open channel â†’ if opened, settle (LSP keeps fee) â†’ if failed, cancel (client refunded).`,
      },
    ],
  },
  {
    id: "wrapped-invoices",
    title: "Wrapped Invoices",
    description:
      "Act as a non-custodial payment intermediary by wrapping an invoice with a higher amount using the same payment hash.",
    education:
      "Wrapped invoices allow you to act as a non-custodial middleman in a payment flow. By creating a hold invoice with the same payment hash as another invoice (but a higher amount), you can collect a fee for facilitating the payment. Crucially, the payer's funds remain locked in the Lightning network - never in your wallet - until you settle. You must use your own liquidity to pay the original invoice first, receiving the preimage, which you then use to settle the held payment and claim your fee. This non-custodial pattern is the manual equivalent of how Lightning routing works.\n\nâš ï¸ Important: Bob's wrapped invoice must have a higher min_final_cltv_expiry_delta than Charlie's original invoice. This ensures Bob has enough time to settle Alice's payment after receiving the preimage from paying Charlie. If the deltas are misconfigured, Bob risks Alice's payment timing out before he can settle it.",
    howItWorks: [
      {
        title: "Charlie Creates",
        description:
          "Charlie creates a regular invoice. Bob receives it and extracts the payment hash.",
      },
      {
        title: "Bob Wraps",
        description:
          "Bob creates a hold invoice with the SAME payment hash but higher amount (adding his fee).",
      },
      {
        title: "Alice Pays Bob",
        description:
          "Alice pays Bob's wrapped invoice. Funds are HELD in the network (not in Bob's wallet).",
      },
      {
        title: "Bob Pays Charlie",
        description:
          "Bob pays Charlie's original invoice using his OWN funds. He receives the preimage.",
      },
      {
        title: "Bob Settles",
        description:
          "Bob uses the preimage to settle Alice's held payment. Bob keeps the fee difference.",
      },
    ],
    complexity: "expert",
    requiredWallets: ["alice", "bob", "charlie"],
    icon: "ğŸ",
    snippetIds: [
      "make-invoice",
      "wrapped-hold-invoice",
      "subscribe-hold-notifications",
      "pay-invoice",
      "hold-invoice-settle",
    ] satisfies SnippetId[],
    prompts: [
      {
        title: "Stacker News Clone",
        description:
          "Build a social news site where the platform earns revenue from zaps using wrapped invoices, while preventing sybil attacks.",
        prompt: `Build a Stacker News-style social news site that uses wrapped invoices to earn platform revenue from zaps.

Requirements:
- A feed of user-submitted posts (title, link, author)
- Users can zap (tip) posts with Lightning payments
- When a user zaps a post:
  - The post author creates an invoice for the zap amount
  - The platform wraps that invoice, adding a platform fee (e.g. 10%)
  - The zapper pays the wrapped invoice to the platform
  - The platform pays the original invoice to the author, keeping the fee & preventing sybil attacks
- Display zap counts and totals on each post
- Show a leaderboard of top-zapped posts and top earners
- Display platform revenue from fees
- Use React and TypeScript
- Write tests using vitest and playwright. Take screenshots and review the screenshots.

The flow: User submits post â†’ another user zaps â†’ platform wraps author's invoice with fee â†’ zapper pays platform â†’ platform pays author â†’ platform keeps fee.`,
      },
      {
        title: "Lightning Trampoline Service",
        description:
          "Build a privacy-preserving trampoline service that hides payment recipients in exchange for a fee.",
        prompt: `Build a Lightning trampoline service that provides payment privacy by hiding the true recipient.

Requirements:
- A service where users can make payments without revealing the final destination
- The flow:
  - User provides the recipient's invoice they want to pay privately
  - The trampoline service extracts the payment hash from the invoice
  - The service creates a wrapped hold invoice with the same payment hash, adding a privacy fee (e.g. 5%)
  - User pays the trampoline's wrapped invoice
  - The trampoline pays the original recipient invoice using its own node, receiving the preimage
  - The trampoline settles the user's payment with the preimage
- Privacy benefits to explain to users:
  - The recipient only sees the trampoline node, not the payer's node
  - The payer's node only sees the trampoline, not the recipient
  - Network observers cannot link payer to recipient
- Display the payment flow visually showing the privacy barrier
- Show service stats: payments processed, total fees earned
- Include a fee calculator so users know the total cost before paying
- Handle edge cases: expired invoices, failed payments (cancel and refund)
- Use React and TypeScript
- Write tests using vitest and playwright. Take screenshots and review the screenshots.

The flow: User pastes recipient invoice â†’ service wraps it with fee â†’ user pays service â†’ service pays recipient privately â†’ service settles user payment â†’ privacy preserved.`,
      },
    ],
  },
  {
    id: "decode-bolt11-invoice",
    title: "Invoice Decoding",
    description:
      "Decode an invoice to verify or read its properties, useful when an invoice is provided by an end-user.",
    education:
      "A BOLT-11 invoice can be decoded into its separate fields, to access for example the invoice amount, description, payment hash, and expiry. This is useful for verifying invoice details before paying or displaying them to users.",
    complexity: "medium",
    requiredWallets: [],
    icon: "ğŸ”",
    snippetIds: ["decode-invoice"] satisfies SnippetId[],
    prompts: [
      {
        title: "Invoice Inspector Tool",
        description:
          "Build a developer tool that decodes and displays all fields of a BOLT-11 Lightning invoice.",
        prompt: `Build a Lightning invoice inspector/decoder tool.

Requirements:
- A text input where users can paste a BOLT-11 invoice string
- Decode the invoice and display all fields in a clear, labeled format:
  - Amount (in sats and millisats)
  - Description / purpose
  - Payment hash
  - Payee public key
  - Expiry time and whether it's expired
  - Creation timestamp
  - Route hints (if any)
- Add a "Copy" button for each field value
- Highlight if the invoice is expired
- Use React and TypeScript
- Write tests using vitest and playwright. Take screenshots and review the screenshots.

The flow: Paste invoice â†’ decode â†’ display all fields with labels and copy buttons.`,
      },
      {
        title: "Verify Customer Payout Invoice",
        description:
          "Build a service that accepts a customer-provided invoice and verifies its amount and expiry before paying it out.",
        prompt: `Build a payout verification service that decodes and validates a customer-submitted Lightning invoice before paying it.

Requirements:
- A form where the customer pastes their BOLT-11 invoice
- The service has a preconfigured expected payout amount (e.g. set via an input or dropdown: 1000, 5000, 10000 sats)
- On submission, decode the invoice and display the parsed fields: amount, description, expiry, and payment hash
- Validate the invoice against business rules:
  - Amount must exactly match the expected payout amount â€” reject if it differs
  - Invoice must not be expired â€” reject if the expiry time has passed
  - Invoice must have enough remaining time before expiry (e.g. at least 60 seconds) â€” warn or reject if too close
- Show a clear pass/fail status for each validation check with green checkmarks or red crosses
- If all checks pass, show an "Approve & Pay" button that pays the invoice
- If any check fails, show an error summary explaining what went wrong and do not allow payment
- Display the result after payment (success or failure)
- Use React and TypeScript
- Write tests using vitest and playwright. Take screenshots and review the screenshots.

The flow: Set expected payout amount â†’ customer pastes invoice â†’ decode â†’ validate amount and expiry â†’ approve and pay or reject with reason.`,
      },
    ],
  },
  {
    id: "proof-of-payment",
    title: "Proof of Payment",
    description:
      "Use the payment preimage as cryptographic proof that a payment was made.",
    education:
      "Every Lightning payment includes a preimage that serves as cryptographic proof of payment. This can be used to unlock content, verify purchases, as a receipt, or to enable atomic swaps. The preimage is atomically revealed on successful payment. Payment hash in a BOLT-11 invoice is the SHA-256 hash of the preimage.",
    complexity: "medium",
    requiredWallets: [],
    icon: "âœ…",
    snippetIds: [
      "make-invoice",
      "pay-invoice",
      "validate-preimage",
    ] satisfies SnippetId[],
    prompts: [
      {
        title: "Secret Exchange",
        description:
          "Build an atomic secret exchange where the seller encrypts data with the preimage and the buyer decrypts it after payment.",
        prompt: `Build an atomic secret exchange where paying a Lightning invoice reveals the key to decrypt a secret.

Requirements:
- The seller has secret data (e.g. an API key, download link, or password)
- The seller generates a random preimage, then encrypts the secret data using the preimage as the symmetric encryption key (e.g. AES-256)
- The seller also publishes a hash of the plaintext secret, so the buyer can verify correctness after decryption
- The seller creates an invoice from the preimage hash and shares the encrypted data + plaintext hash + invoice with the buyer
- The buyer sees the item description, price, encrypted blob, and plaintext hash â€” but cannot read the secret yet
- The buyer pays the invoice
- The payment preimage is atomically revealed upon successful payment
- The buyer uses the preimage to decrypt the secret data
- The buyer hashes the decrypted result and compares it to the published plaintext hash to verify they got the correct data
- Display the decryption step-by-step: preimage â†’ decrypt â†’ verify hash â†’ show secret
- Note: the plaintext hash commitment makes fraud provable after the fact â€” the buyer can show that the decrypted data doesn't match the committed hash
- Use React and TypeScript
- Write tests using vitest and playwright. Take screenshots and review the screenshots.

The flow: Seller encrypts secret with preimage, publishes ciphertext + plaintext hash â†’ buyer pays â†’ preimage revealed â†’ buyer decrypts and verifies.`,
      },
    ],
  },
  // {
  //   id: "transaction-history",
  //   title: "Transaction History",
  //   description: "Fetch and display transaction history from a wallet.",
  //   education:
  //     "NWC allows you to query the transaction history of a wallet, useful for displaying past payments and receipts in your application.",
  //   complexity: "medium",
  //   requiredWallets: ["alice", "bob", "charlie", "david"],
  //   icon: "ğŸ“œ",
  // },
  /*{
    id: "nostr-zap",
    title: "Nostr Zap",
    description: "Send a zap (payment) to a Nostr user or content.",
    education:
      "Zaps are Lightning payments sent through Nostr, typically used to tip content creators. They combine Lightning payments with Nostr social features.",
    complexity: "advanced",
    requiredWallets: ["alice", "bob"],
    icon: "âš¡",
  },*/
  {
    id: "payment-forwarding",
    title: "Payment Forwarding",
    description:
      "Listen to incoming payments, and forward a percentage of the value using a recipient lightning address.",
    education:
      "Payment forwarding can be used to make revenue by providing a service for merchants. For example, receive the payment on behalf of a merchant, provide a service, and then forward 99% of the value to the merchant. Keep in mind, you should reserve 1% for routing fees.",
    howItWorks: [
      {
        title: "Configure",
        description:
          "Bob sets up forwarding to Charlie's lightning address with a percentage.",
      },
      {
        title: "Receive",
        description:
          "Alice pays Bob. Bob's wallet receives the payment notification.",
      },
      {
        title: "Forward",
        description:
          "Bob automatically forwards the configured percentage to Charlie.",
      },
    ],
    complexity: "medium",
    requiredWallets: ["alice", "bob", "charlie"],
    icon: "ğŸ”€",
    snippetIds: [
      "subscribe-notifications",
      "request-invoice-from-address",
      "pay-lightning-address",
      "pay-invoice",
    ] satisfies SnippetId[],
    prompts: [
      {
        title: "Income Splitter",
        description:
          "Build a service that receives payments and automatically forwards a percentage to another Lightning Address.",
        prompt: `Build an income splitter service that forwards a percentage of incoming payments.

Requirements:
- Configuration panel to set:
  - Forwarding recipient (Lightning Address)
  - Forwarding percentage (e.g. 80%)
  - Reserve percentage for routing fees (e.g. 1%)
- Subscribe to incoming payment notifications
- When a payment is received:
  - Calculate the forwarding amount based on the configured percentage
  - Request an invoice from the recipient's Lightning Address and pay it
- Display a live log of received payments and forwarded amounts
- Show a running summary: total received, total forwarded, total retained
- Use React and TypeScript
- Write tests using vitest and playwright. Take screenshots and review the screenshots.

The flow: Configure split â†’ receive payment â†’ calculate forward amount â†’ pay to Lightning Address â†’ log result.`,
      },
    ],
  },
  {
    id: "payment-prisms",
    title: "Payment Prisms",
    description:
      "Listen to incoming payments, and forward a percentage of the value to multiple recipients.",
    education:
      "Prisms is an extension of payment forwarding that allows a single initial payment to fund multiple wallets. Prisms can also be recursive. Make sure to consider reserving 1% for routing fees for each payment.",
    howItWorks: [
      {
        title: "Configure",
        description:
          "Bob sets up a prism split with percentages for Charlie and David.",
      },
      {
        title: "Receive",
        description:
          "Alice pays Bob. Bob's wallet receives the payment notification.",
      },
      {
        title: "Split",
        description:
          "Bob automatically splits the payment, forwarding to Charlie and David.",
      },
    ],
    complexity: "advanced",
    requiredWallets: ["alice", "bob", "charlie", "david"],
    icon: "ğŸ”º",
    snippetIds: [
      "subscribe-notifications",
      "request-invoice-from-address",
      "pay-lightning-address",
      "pay-invoice",
    ] satisfies SnippetId[],
    prompts: [
      {
        title: "Band Revenue Splitter",
        description:
          "Build a payment page for a band that automatically splits incoming payments among all members.",
        prompt: `Build a band revenue splitter that distributes incoming payments to multiple members.

Requirements:
- Configuration panel to set up band members:
  - Each member has a name, Lightning Address, and split percentage
  - Support 2-5 members
  - Percentages must total 100% (minus a reserve for routing fees)
- A payment page that shows the band name and a QR code / Lightning Address for receiving payments
- Subscribe to incoming payment notifications
- When a payment is received:
  - Calculate each member's share based on their percentage
  - Request invoices from each member's Lightning Address and pay them
- Display a live split log showing each distribution
- Show per-member totals and an overall summary
- Use React and TypeScript
- Write tests using vitest and playwright. Take screenshots and review the screenshots.

The flow: Configure members & splits â†’ receive payment â†’ calculate shares â†’ pay each member â†’ log distributions.`,
      },
    ],
  },
  {
    id: "fiat-conversion",
    title: "Fiat Conversion",
    description: "Convert between sats and fiat currencies for display.",
    education:
      "Many apps need to display Bitcoin amounts in familiar fiat currencies. Learn how to fetch exchange rates and convert amounts.",
    complexity: "simple",
    requiredWallets: [],
    icon: "ğŸ’±",
    snippetIds: [
      "get-fiat-currencies",
      "sats-to-fiat",
      "fiat-to-sats",
      "get-btc-rate",
    ] satisfies SnippetId[],
    prompts: [
      {
        title: "Bitcoin Price Converter",
        description:
          "Build a real-time converter tool between sats and multiple fiat currencies.",
        prompt: `Build a Bitcoin/sats to fiat currency converter.

Requirements:
- Input field for an amount in sats
- Dropdown to select fiat currency (USD, EUR, GBP, JPY, etc.)
- Display the converted fiat amount in real time as the user types
- Also support reverse conversion: input fiat amount, show equivalent in sats
- Show the current exchange rate (sats per dollar, etc.)
- Use React and TypeScript
- Write tests using vitest and playwright. Take screenshots and review the screenshots.

The flow: Enter amount â†’ select currency â†’ see converted value in real time.`,
      },
    ],
  },
  // Bitcoin Connect items
  {
    id: "connect-wallet",
    title: "Connect Wallet Modal",
    description:
      "Use Bitcoin Connect to let users connect their Lightning wallet with a single click.",
    education:
      "Bitcoin Connect provides a universal wallet connection modal that supports multiple wallet types including NWC, browser extensions, and mobile apps. It abstracts away the complexity of wallet integration, making it easy to add Lightning payments to any web application.",
    icon: "ğŸ”—",
    section: "bitcoin-connect",
    complexity: "simple",
    snippetIds: ["bc-init", "bc-launch-modal", "bc-disconnect"],
  },
];

const getComplexityIndex = (complexity: ScenarioComplexity) => {
  switch (complexity) {
    case "simplest":
      return 0;
    case "simple":
      return 1;
    case "medium":
      return 2;
    case "advanced":
      return 3;
    case "expert":
      return 4;
  }
};

const getSectionIndex = (section?: ScenarioSection) => {
  if (!section || section === "scenarios") return 0;
  if (section === "bitcoin-connect") return 1;
  return 2;
};

export const scenarios = unorderedScenarios.sort((a, b) => {
  // First sort by section
  const sectionDiff = getSectionIndex(a.section) - getSectionIndex(b.section);
  if (sectionDiff !== 0) return sectionDiff;
  // Then sort by complexity within each section
  return getComplexityIndex(a.complexity) - getComplexityIndex(b.complexity);
});

export function getScenarioById(id: string): Scenario | undefined {
  return scenarios.find((s) => s.id === id);
}
